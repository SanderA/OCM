!> \file
!> \author Chris Bradley
!> \brief This module handles all constraint equations routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!>This module handles all constraint equations routines.
MODULE CONSTRAINT_EQUATIONS_ROUTINES

  USE BASE_ROUTINES
  USE EQUATIONS_ROUTINES
  USE FIELD_ROUTINES
  USE CONSTRAINT_CONDITIONS_CONSTANTS
  USE CONSTRAINT_MAPPING_ROUTINES
  USE CONSTRAINT_MATRICES_ROUTINES
  USE ISO_VARYING_STRING
  USE KINDS
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !> \addtogroup CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes CONSTRAINT_EQUATIONS_ROUTINES::OutputTypes
  !> \brief The constraint equations output types
  !> \see CONSTRAINT_EQUATIONS_ROUTINES,OPENCMISS_ConstraintEquationsConstants
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_NO_OUTPUT=0 !<No output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_TIMING_OUTPUT=1 !<Timing information output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_MATRIX_OUTPUT=2 !<All below and equation matrices output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT=3 !<All below and element matrices output .\see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES 
  !>@}

  !> \addtogroup CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes CONSTRAINT_EQUATIONS_ROUTINES::SparsityTypes
  !> \brief Constraint equations matrices sparsity types
  !> \see CONSTRAINT_EQUATIONS_ROUTINES,OPENCMISS_ConstraintEquationsSparsityTypes
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_SPARSE_MATRICES=1 !<Use sparse matrices for the constraint equations. \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_FULL_MATRICES=2 !<Use fully populated matrices for the constraint equations. \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
 !>@}

  !Module types

  !Module variables

  !Constraints

  PUBLIC CONSTRAINT_EQUATIONS_NO_OUTPUT,CONSTRAINT_EQUATIONS_TIMING_OUTPUT,CONSTRAINT_EQUATIONS_MATRIX_OUTPUT, &
    & CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT

  PUBLIC CONSTRAINT_EQUATIONS_SPARSE_MATRICES,CONSTRAINT_EQUATIONS_FULL_MATRICES

  PUBLIC CONSTRAINT_EQUATIONS_CREATE_FINISH,CONSTRAINT_EQUATIONS_CREATE_START

  PUBLIC CONSTRAINT_EQUATIONS_DESTROY

  PUBLIC CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET

  PUBLIC CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET,CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET
  
  PUBLIC CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET,CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET

  PUBLIC CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET

  PUBLIC CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET,CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET

  PUBLIC CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET,CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET

  PUBLIC CONSTRAINT_CONDITION_EQUATIONS_GET
  
CONTAINS

  !
  !================================================================================================================================
  !

  !>Finish the creation of constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_FINISH(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,GEOMETRIC_FIELD,LAGRANGE_FIELD,PENALTY_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DEPENDENT_VARIABLE
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION
    TYPE(CONSTRAINT_DEPENDENT_TYPE), POINTER :: CONSTRAINT_DEPENDENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_EQUATIONS_CREATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations have already been finished.",ERR,ERROR,*999)
      ELSE
        !Create the interpolation sets
        CONSTRAINT_CONDITION=>CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION
        IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
          SELECT CASE(CONSTRAINT_CONDITION%METHOD)
          CASE(CONSTRAINT_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,CONSTRAINT_CONDITION_PENALTY_METHOD)
            IF(ASSOCIATED(CONSTRAINT_CONDITION%LAGRANGE)) THEN
              CONSTRAINT_DEPENDENT=>CONSTRAINT_CONDITION%DEPENDENT
              IF(ASSOCIATED(CONSTRAINT_DEPENDENT)) THEN
                IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION)) THEN
                  GEOMETRIC_FIELD=>CONSTRAINT_CONDITION%GEOMETRY%GEOMETRIC_FIELD
                  LAGRANGE_FIELD=>CONSTRAINT_CONDITION%LAGRANGE%LAGRANGE_FIELD
                  NULLIFY(PENALTY_FIELD)
                  IF(ASSOCIATED(CONSTRAINT_CONDITION%PENALTY)) THEN
                    PENALTY_FIELD=>CONSTRAINT_CONDITION%PENALTY%PENALTY_FIELD
                  ENDIF
                  !\todo Truncating subroutine name from CONSTRAINT_EQUATIONS_DOMAIN_CONSTRAINT_INTERPOLATION_SETUP until bug in gfortran 4.6 is fixed http://gcc.gnu.org/bugzilla/show_bug.cgi?id=46971
                  CALL CONSTRAINT_EQUATIONS_DOMAIN_CONSTRAINT_INTERPOLATION_(CONSTRAINT_EQUATIONS%INTERPOLATION% &
                    & CONSTRAINT_INTERPOLATION,GEOMETRIC_FIELD,LAGRANGE_FIELD,PENALTY_FIELD,ERR,ERROR,*999)
                  DO variable_idx=1,CONSTRAINT_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
                    DEPENDENT_VARIABLE=>CONSTRAINT_DEPENDENT%FIELD_VARIABLES(variable_idx)%PTR
                    IF(ASSOCIATED(DEPENDENT_VARIABLE)) THEN
                      DEPENDENT_FIELD=>DEPENDENT_VARIABLE%FIELD
                      IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                        GEOMETRIC_FIELD=>DEPENDENT_FIELD%GEOMETRIC_FIELD
                        CALL CONSTRAINT_EQUATIONS_DOMAIN_VARIABLE_INTERPOLATION_SETUP(CONSTRAINT_EQUATIONS%INTERPOLATION% &
                          & VARIABLE_INTERPOLATION(variable_idx),GEOMETRIC_FIELD,DEPENDENT_FIELD,ERR,ERROR,*999)
                      ELSE
                        CALL FLAG_ERROR("Dependent variable field is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="Dependent variable is not associated for variable index "// &
                        & TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDDO !variable_idx
                ELSE
                  CALL FLAG_ERROR("Constraint equations interpolation is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Constraint condition dependent is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint condition Lagrange is not associated.",ERR,ERROR,*999)
            ENDIF
          CASE(CONSTRAINT_CONDITION_AUGMENTED_LAGRANGE_METHOD)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE(CONSTRAINT_CONDITION_POINT_TO_POINT_METHOD)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The constraint condition method of "// &
              & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_CONDITION%METHOD,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
          !Set the finished flag
          CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED=.TRUE.
        ELSE
          CALL FLAG_ERROR("Constraint equations constraint condition is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_FINISH")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_CREATE_FINISH",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_FINISH")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Start the creation of constraint equations for an constraint condition.
  SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_START(CONSTRAINT_CONDITION,CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint condition to create constraint equations for
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<On exit, a pointer to the created constraint equations. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_CREATE_START",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(ASSOCIATED(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS)) THEN
        CALL FLAG_ERROR("Constraint equations are already associated for the constraint condition.",ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
          CALL FLAG_ERROR("Constraint equations is already associated.",ERR,ERROR,*999)
        ELSE
          !Initialise the equations
          CALL CONSTRAINT_EQUATIONS_INITIALISE(CONSTRAINT_CONDITION,ERR,ERROR,*999)
          !Return the pointer
          CONSTRAINT_EQUATIONS=>CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint condition is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_START")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_CREATE_START",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_START")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_START

  !
  !================================================================================================================================
  !

  !>Destroys constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_DESTROY(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CALL CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_DESTROY")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_DESTROY",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DESTROY")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the constraint equations domain interpolation and deallocates all memory.
  SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE(DOMAIN_INTERPOLATION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_TYPE) :: DOMAIN_INTERPOLATION !<The domain interpolation to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: interpolation_set_idx
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE",ERR,ERROR,*999)

    NULLIFY(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD)
    IF(ALLOCATED(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION)) THEN
      DO interpolation_set_idx=1,SIZE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION,1)
        CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx), &
          & ERR,ERROR,*999)
      ENDDO !interpolation_set_idx
      DEALLOCATE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION)
    ENDIF
    DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS=0
    NULLIFY(DOMAIN_INTERPOLATION%DEPENDENT_FIELD)
    IF(ALLOCATED(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION)) THEN
     DO interpolation_set_idx=1,SIZE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION,1)
        CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx), &
          & ERR,ERROR,*999)
      ENDDO !interpolation_set_idx
      DEALLOCATE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION)
    ENDIF
    DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS=0
       
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the constraint equations domain interpolation.
  SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE(DOMAIN_INTERPOLATION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_TYPE) :: DOMAIN_INTERPOLATION !<The domain interpolation to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE",ERR,ERROR,*999)

    NULLIFY(DOMAIN_INTERPOLATION%PENALTY_FIELD)
    DOMAIN_INTERPOLATION%NUMBER_OF_PENALTY_INTERPOLATION_SETS=1
    NULLIFY(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD)
    DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS=1
    NULLIFY(DOMAIN_INTERPOLATION%DEPENDENT_FIELD)
    DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS=1
       
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets up the constraint equations domain constraint interpolation. !\todo Truncating subroutine name from CONSTRAINT_EQUATIONS_DOMAIN_CONSTRAINT_INTERPOLATION_SETUP until bug in gfortran 4.6 is fixed http://gcc.gnu.org/bugzilla/show_bug.cgi?id=46971
  SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_CONSTRAINT_INTERPOLATION_(DOMAIN_INTERPOLATION,GEOMETRIC_FIELD,LAGRANGE_FIELD, &
    & PENALTY_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_TYPE) :: DOMAIN_INTERPOLATION !<The domain interpolation to initialise
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field to set up the domain interpolation for
    TYPE(FIELD_TYPE), POINTER :: LAGRANGE_FIELD !<A pointer to the Lagrange field to set up the domain interpoaltion for
    TYPE(FIELD_TYPE), POINTER :: PENALTY_FIELD !<A pointer to the penalty field to set up the domain interpoaltion for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,interpolation_set_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP",ERR,ERROR,*998)

    IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
      IF(ASSOCIATED(LAGRANGE_FIELD)) THEN
        DOMAIN_INTERPOLATION%GEOMETRIC_FIELD=>GEOMETRIC_FIELD
        ALLOCATE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS), &
          & STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate domain interpolation geometric interpolation.",ERR,ERROR,*999)
        DO interpolation_set_idx=1,DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS
          CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION( &
            & interpolation_set_idx),ERR,ERROR,*999)
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD,DOMAIN_INTERPOLATION% &
            & GEOMETRIC_INTERPOLATION(interpolation_set_idx)%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)% &
            & INTERPOLATION_PARAMETERS,DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)%INTERPOLATED_POINT, &
            & ERR,ERROR,*999)
          IF(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR. &
            & DOMAIN_INTERPOLATION%GEOMETRIC_FIELD%TYPE==FIELD_FIBRE_TYPE) THEN
            CALL FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION( &
              & interpolation_set_idx)%INTERPOLATED_POINT,DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)% &
              & INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
          ENDIF
        ENDDO !interpolation_set_idx
        DOMAIN_INTERPOLATION%DEPENDENT_FIELD=>LAGRANGE_FIELD
        ALLOCATE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS), &
          & STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate domain interpolation dependent interpolation.",ERR,ERROR,*999)
        DO interpolation_set_idx=1,DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS
          CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION( &
            & interpolation_set_idx),ERR,ERROR,*999)
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_FIELD,DOMAIN_INTERPOLATION% &
            & DEPENDENT_INTERPOLATION(interpolation_set_idx)%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx)% &
            & INTERPOLATION_PARAMETERS,DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx)%INTERPOLATED_POINT, &
            & ERR,ERROR,*999)
        ENDDO !interpolation_set_idx
        IF(ASSOCIATED(PENALTY_FIELD)) THEN
          DOMAIN_INTERPOLATION%PENALTY_FIELD=>PENALTY_FIELD
          ALLOCATE(DOMAIN_INTERPOLATION%PENALTY_INTERPOLATION(DOMAIN_INTERPOLATION%NUMBER_OF_PENALTY_INTERPOLATION_SETS), &
            & STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate domain interpolation dependent interpolation.",ERR,ERROR,*999)
          DO interpolation_set_idx=1,DOMAIN_INTERPOLATION%NUMBER_OF_PENALTY_INTERPOLATION_SETS
            CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(DOMAIN_INTERPOLATION%PENALTY_INTERPOLATION( &
              & interpolation_set_idx),ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(DOMAIN_INTERPOLATION%PENALTY_FIELD,DOMAIN_INTERPOLATION% &
              & PENALTY_INTERPOLATION(interpolation_set_idx)%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(DOMAIN_INTERPOLATION%PENALTY_INTERPOLATION(interpolation_set_idx)% &
              & INTERPOLATION_PARAMETERS,DOMAIN_INTERPOLATION%PENALTY_INTERPOLATION(interpolation_set_idx)%INTERPOLATED_POINT, &
              & ERR,ERROR,*999)
          ENDDO !interpolation_set_idx
        ENDIF
      ELSE
        CALL FLAG_ERROR("Lagrange field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Geometric field is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE(DOMAIN_INTERPOLATION,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_CONSTRAINT_INTERPOLATION_

  !
  !================================================================================================================================
  !

  !>Sets up the constraint equations domain variable interpolation. \todo Truncating subroutine name until bug in gfortran 4.6 is fixed http://gcc.gnu.org/bugzilla/show_bug.cgi?id=46971
  SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_VARIABLE_INTERPOLATION_SETUP(DOMAIN_INTERPOLATION,GEOMETRIC_FIELD,DEPENDENT_FIELD, &
    &  ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_TYPE) :: DOMAIN_INTERPOLATION !<The domain interpolation to initialise
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field to set up the domain interpolation for
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD !<A pointer to the depdendent field to set up the domain interpoaltion for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,interpolation_set_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP",ERR,ERROR,*998)

    IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
      IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
        DOMAIN_INTERPOLATION%GEOMETRIC_FIELD=>GEOMETRIC_FIELD
        ALLOCATE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS), &
          & STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate domain interpolation geometric interpolation.",ERR,ERROR,*999)
        DO interpolation_set_idx=1,DOMAIN_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS
          CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION( &
            & interpolation_set_idx),ERR,ERROR,*999)
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD,DOMAIN_INTERPOLATION% &
            & GEOMETRIC_INTERPOLATION(interpolation_set_idx)%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)% &
            & INTERPOLATION_PARAMETERS,DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)%INTERPOLATED_POINT, &
            & ERR,ERROR,*999)
          IF(DOMAIN_INTERPOLATION%GEOMETRIC_FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR. &
            & DOMAIN_INTERPOLATION%GEOMETRIC_FIELD%TYPE==FIELD_FIBRE_TYPE) THEN
            CALL FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION( &
              & interpolation_set_idx)%INTERPOLATED_POINT,DOMAIN_INTERPOLATION%GEOMETRIC_INTERPOLATION(interpolation_set_idx)% &
              & INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
          ENDIF
        ENDDO !interpolation_set_idx
        DOMAIN_INTERPOLATION%DEPENDENT_FIELD=>DEPENDENT_FIELD
        ALLOCATE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS), &
          & STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate domain interpolation dependent interpolation.",ERR,ERROR,*999)
        DO interpolation_set_idx=1,DOMAIN_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS
          CALL CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION( &
            & interpolation_set_idx),ERR,ERROR,*999)
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_FIELD,DOMAIN_INTERPOLATION% &
            & DEPENDENT_INTERPOLATION(interpolation_set_idx)%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx)% &
            & INTERPOLATION_PARAMETERS,DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx)%INTERPOLATED_POINT, &
            & ERR,ERROR,*999)
          IF(DOMAIN_INTERPOLATION%DEPENDENT_FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR. &
            & DOMAIN_INTERPOLATION%DEPENDENT_FIELD%TYPE==FIELD_FIBRE_TYPE) THEN
            CALL FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION( &
              & interpolation_set_idx)%INTERPOLATED_POINT,DOMAIN_INTERPOLATION%DEPENDENT_INTERPOLATION(interpolation_set_idx)% &
              & INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
          ENDIF
        ENDDO !interpolation_set_idx
      ELSE
        CALL FLAG_ERROR("Dependent field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Geometric field is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE(DOMAIN_INTERPOLATION,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_SETUP")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DOMAIN_VARIABLE_INTERPOLATION_SETUP

  !
  !================================================================================================================================
  !

  SUBROUTINE CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET(CONSTRAINT_EQUATIONS,NUMBER_OF_GEOMETRIC_SETS, &
     & NUMBER_OF_DEPENDENT_SETS,NUMBER_OF_PENALTY_SETS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<The constraint equations to set the constraint interpolation sets for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_GEOMETRIC_SETS !<The number of geometric constraint interpolation sets to set
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_DEPENDENT_SETS !<The number of dependent constraint interpolation sets to set
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_PENALTY_SETS !<The number of penalty constraint interpolation sets to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations have already been finished.",ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION)) THEN
          IF(NUMBER_OF_GEOMETRIC_SETS>0) THEN
            IF(NUMBER_OF_DEPENDENT_SETS>0) THEN
              IF(NUMBER_OF_PENALTY_SETS>=0) THEN
                CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_INTERPOLATION%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS= &
                  & NUMBER_OF_GEOMETRIC_SETS
                CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_INTERPOLATION%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS= &
                  & NUMBER_OF_DEPENDENT_SETS
                CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_INTERPOLATION%NUMBER_OF_PENALTY_INTERPOLATION_SETS= &
                  & NUMBER_OF_PENALTY_SETS
              ELSE
                LOCAL_ERROR="The specified number of penalty sets of "// &
                  & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_PENALTY_SETS,"*",ERR,ERROR))// &
                  & " is invalid. The number of penalty sets must be > 0."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified number of dependent sets of "// &
                & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_DEPENDENT_SETS,"*",ERR,ERROR))// &
                & " is invalid. The number of dependent sets must be > 0."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified number of geometric sets of "// &
              & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_GEOMETRIC_SETS,"*",ERR,ERROR))// &
              & " is invalid. The number of geometric sets must be > 0."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint equations interpolation is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_CONSTRAINT_INTERP_SETS_NUMBER_SET

  !
  !================================================================================================================================
  !

  !>Finalise the constraint equations and deallocate all memory.
  SUBROUTINE CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CALL CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS%INTERPOLATION,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING)) &
        & CALL CONSTRAINT_MAPPING_DESTROY(CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES)) &
        & CALL CONSTRAINT_MATRICES_DESTROY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)
      DEALLOCATE(CONSTRAINT_EQUATIONS)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the constraint equations for an constraint condition
  SUBROUTINE CONSTRAINT_EQUATIONS_INITIALISE(CONSTRAINT_CONDITION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint condition to initialise the constraint equations for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(ASSOCIATED(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS)) THEN
        CALL FLAG_ERROR("Constraint equations is already associated for this constraint condition.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint equations.",ERR,ERROR,*999)
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION=>CONSTRAINT_CONDITION
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_LINEAR
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_STATIC
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_NO_OUTPUT
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_SPARSE_MATRICES
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%INTERPOLATION)
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING)
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES)
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED=.FALSE.
        CALL CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint condition is not associated.",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INITIALISE")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INITIALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the constraint equations interpolation and deallocates all memory.
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_INTERPOLATION_TYPE), POINTER :: CONSTRAINT_EQUATIONS_INTERPOLATION !<A pointer to the constraint equations interpolation to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS_INTERPOLATION)) THEN
      CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%CONSTRAINT_INTERPOLATION, &
        & ERR,ERROR,*999)
      IF(ALLOCATED(CONSTRAINT_EQUATIONS_INTERPOLATION%VARIABLE_INTERPOLATION)) THEN
        DO variable_idx=1,SIZE(CONSTRAINT_EQUATIONS_INTERPOLATION%VARIABLE_INTERPOLATION,1)
          CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION% &
            & VARIABLE_INTERPOLATION(variable_idx),ERR,ERROR,*999)
        ENDDO !variable_idx
        DEALLOCATE(CONSTRAINT_EQUATIONS_INTERPOLATION%VARIABLE_INTERPOLATION)
      ENDIF
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the constraint equations interpolation.
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to initialise the interpolation for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,variable_idx
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION
    TYPE(CONSTRAINT_DEPENDENT_TYPE), POINTER :: CONSTRAINT_DEPENDENT
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CONSTRAINT_CONDITION=>CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION
      IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION)) THEN
          CALL FLAG_ERROR("Constraint equations interpolation is already associated.",ERR,ERROR,*998)
        ELSE
          CONSTRAINT_DEPENDENT=>CONSTRAINT_CONDITION%DEPENDENT
          IF(ASSOCIATED(CONSTRAINT_DEPENDENT)) THEN
            ALLOCATE(CONSTRAINT_EQUATIONS%INTERPOLATION,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint equations interpolation.",ERR,ERROR,*999)
            CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_EQUATIONS=>CONSTRAINT_EQUATIONS
            CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_INTERPOLATION, &
              & ERR,ERROR,*999)
            CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_INTERPOLATION%INTERPOLATION=>CONSTRAINT_EQUATIONS%INTERPOLATION
            ALLOCATE(CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION(CONSTRAINT_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES), &
              & STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint equations interpolation mesh interpolation.",ERR,ERROR,*999)
            DO variable_idx=1,CONSTRAINT_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES
              CALL CONSTRAINT_EQUATIONS_DOMAIN_INTERPOLATION_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION% &
                & VARIABLE_INTERPOLATION(variable_idx),ERR,ERROR,*999)
                CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION(variable_idx)%INTERPOLATION=> &
                  & CONSTRAINT_EQUATIONS%INTERPOLATION
            ENDDO !variable_idx
          ELSE
            CALL FLAG_ERROR("Constraint condition dependent is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint equations constraint condition is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS%INTERPOLATION,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the constraint equations interpolation set and deallocates all memory.
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE(INTERPOLATION_SET,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_INTERPOLATION_SET_TYPE) :: INTERPOLATION_SET !<The interpolation set to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE",ERR,ERROR,*999)

    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_SET%INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATION_SET%INTERPOLATED_POINT,ERR,ERROR,*999)
    CALL FIELD_INTERPOLATED_POINTS_METRICS_FINALISE(INTERPOLATION_SET%INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_SET_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the constraint equations interpolation set.
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE(INTERPOLATION_SET,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_INTERPOLATION_SET_TYPE) :: INTERPOLATION_SET !<The interpolation set to intialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE",ERR,ERROR,*999)

    NULLIFY(INTERPOLATION_SET%INTERPOLATION_PARAMETERS)
    NULLIFY(INTERPOLATION_SET%INTERPOLATED_POINT)
    NULLIFY(INTERPOLATION_SET%INTERPOLATED_POINT_METRICS)
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_SET_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the output type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET(CONSTRAINT_EQUATIONS,OUTPUT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the output type for
    INTEGER(INTG), INTENT(OUT) :: OUTPUT_TYPE !<On exit, the output type of the constraint equations \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        OUTPUT_TYPE=CONSTRAINT_EQUATIONS%OUTPUT_TYPE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for the constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET(CONSTRAINT_EQUATIONS,OUTPUT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the output type for
    INTEGER(INTG), INTENT(IN) :: OUTPUT_TYPE !<The output type to set \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(OUTPUT_TYPE)
        CASE(CONSTRAINT_EQUATIONS_NO_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_NO_OUTPUT
        CASE(CONSTRAINT_EQUATIONS_TIMING_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_TIMING_OUTPUT
        CASE(CONSTRAINT_EQUATIONS_MATRIX_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_MATRIX_OUTPUT
        CASE(CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT
        CASE DEFAULT
          LOCAL_ERROR="The specified output type of "//TRIM(NUMBER_TO_VSTRING(OUTPUT_TYPE,"*",ERR,ERROR))//" is invalid"
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET(CONSTRAINT_EQUATIONS,SPARSITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the sparsity type for
    INTEGER(INTG), INTENT(OUT) :: SPARSITY_TYPE !<On exit, the sparsity type of the constraint equations. \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        SPARSITY_TYPE=CONSTRAINT_EQUATIONS%SPARSITY_TYPE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for the constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET(CONSTRAINT_EQUATIONS,SPARSITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the sparsity type for
    INTEGER(INTG), INTENT(IN) :: SPARSITY_TYPE !<The sparsity type to set \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(SPARSITY_TYPE)
        CASE(CONSTRAINT_EQUATIONS_SPARSE_MATRICES)
          CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_SPARSE_MATRICES
        CASE(CONSTRAINT_EQUATIONS_FULL_MATRICES)
          CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_FULL_MATRICES
        CASE DEFAULT
          LOCAL_ERROR="The specified sparsity type of "//TRIM(NUMBER_TO_VSTRING(SPARSITY_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Gets the linearity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET(CONSTRAINT_EQUATIONS,LINEARITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the linearity for
    INTEGER(INTG), INTENT(OUT) :: LINEARITY_TYPE !<On exit, the linearity type of the constraint equations. \see CONSTRAINT_CONDITIONS_CONSTANTS_LinearityTypes,CONSTRAINT_CONDITIONS_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        LINEARITY_TYPE=CONSTRAINT_EQUATIONS%LINEARITY
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET(CONSTRAINT_EQUATIONS,LINEARITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the linearity for
    INTEGER(INTG), INTENT(IN) :: LINEARITY_TYPE !<The linearity type to set \see CONSTRAINT_CONDITIONS_CONSTANTS_LinearityTypes,CONSTRAINT_CONDITIONS_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(LINEARITY_TYPE)
        CASE(CONSTRAINT_CONDITION_LINEAR)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_LINEAR
        CASE(CONSTRAINT_CONDITION_NONLINEAR)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_NONLINEAR
        CASE(CONSTRAINT_CONDITION_NONLINEAR_BCS)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_NONLINEAR_BCS
        CASE DEFAULT
          LOCAL_ERROR="The specified linearity type of "//TRIM(NUMBER_TO_VSTRING(LINEARITY_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET(CONSTRAINT_EQUATIONS,TIME_DEPENDENCE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the output type for
    INTEGER(INTG), INTENT(OUT) :: TIME_DEPENDENCE_TYPE !<On exit, the time dependence type of the constraint equations
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        TIME_DEPENDENCE_TYPE=CONSTRAINT_EQUATIONS%TIME_DEPENDENCE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET(CONSTRAINT_EQUATIONS,TIME_DEPENDENCE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the linearity for
    INTEGER(INTG), INTENT(IN) :: TIME_DEPENDENCE_TYPE !<The time dependence type to set \see CONSTRAINT_CONDITIONS_CONSTANTS_TimeDependenceTypes,CONSTRAINT_CONDITIONS_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(TIME_DEPENDENCE_TYPE)
        CASE(CONSTRAINT_CONDITION_STATIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_STATIC
        CASE(CONSTRAINT_CONDITION_FIRST_ORDER_DYNAMIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_FIRST_ORDER_DYNAMIC
        CASE(CONSTRAINT_CONDITION_SECOND_ORDER_DYNAMIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_SECOND_ORDER_DYNAMIC
        CASE DEFAULT
          LOCAL_ERROR="The specified time dependence type of "//TRIM(NUMBER_TO_VSTRING(TIME_DEPENDENCE_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET

  !
  !================================================================================================================================
  !

  SUBROUTINE CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET(CONSTRAINT_EQUATIONS,VARIABLE_INDEX, &
    & NUMBER_OF_GEOMETRIC_SETS,NUMBER_OF_DEPENDENT_SETS,NUMBER_OF_PENALTY_SETS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<The constraint equations to set the constraint interpolation sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_INDEX !<The variable index number to set the number of interpolation sets for.
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_GEOMETRIC_SETS !<The number of geometric constraint interpolation sets to set
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_DEPENDENT_SETS !<The number of dependent constraint interpolation sets to set
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_PENALTY_SETS !<The number of dependent constraint interpolation sets to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION
    TYPE(CONSTRAINT_DEPENDENT_TYPE), POINTER :: CONSTRAINT_DEPENDENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations have already been finished.",ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION)) THEN
          IF(ALLOCATED(CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION)) THEN
            CONSTRAINT_CONDITION=>CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION
            IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
              CONSTRAINT_DEPENDENT=>CONSTRAINT_CONDITION%DEPENDENT
              IF(ASSOCIATED(CONSTRAINT_DEPENDENT)) THEN
                IF(VARIABLE_INDEX>0.AND.VARIABLE_INDEX<=CONSTRAINT_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES) THEN
                  IF(NUMBER_OF_GEOMETRIC_SETS>0) THEN
                    IF(NUMBER_OF_DEPENDENT_SETS>0) THEN
                      CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION(VARIABLE_INDEX)% &
                        & NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS=NUMBER_OF_GEOMETRIC_SETS
                      CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION(VARIABLE_INDEX)% &
                        & NUMBER_OF_DEPENDENT_INTERPOLATION_SETS=NUMBER_OF_DEPENDENT_SETS
                      CONSTRAINT_EQUATIONS%INTERPOLATION%VARIABLE_INTERPOLATION(VARIABLE_INDEX)% &
                        & NUMBER_OF_PENALTY_INTERPOLATION_SETS=NUMBER_OF_PENALTY_SETS
                    ELSE
                      LOCAL_ERROR="The specified number of dependent sets of "// &
                        & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_DEPENDENT_SETS,"*",ERR,ERROR))// &
                        & " is invalid. The number of dependent sets must be > 0."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified number of geometric sets of "// &
                      & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_GEOMETRIC_SETS,"*",ERR,ERROR))// &
                      & " is invalid. The number of geometric sets must be > 0."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The specified variable index of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_INDEX,"*",ERR,ERROR))// &
                    & " is invalid. The index needs to be > 0 and <= "// &
                    & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_DEPENDENT%NUMBER_OF_DEPENDENT_VARIABLES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Constraint condition dependent is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint equations constraint condition is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Constraint equations interpolation variable interpolation is not allocated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint equations interpolation is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_VARIABLE_INTERP_SETS_NUMBER_SET

  !
  !================================================================================================================================
  !

  !>Gets the constraint equations for an constraint conditions.
  SUBROUTINE CONSTRAINT_CONDITION_EQUATIONS_GET(CONSTRAINT_CONDITION,CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint conditions to get the constraint equations for
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<On exit, a pointer to the constraint equations in the specified constraint condition. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_CONDITION_EQUATIONS_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(CONSTRAINT_CONDITION%CONSTRAINT_CONDITION_FINISHED) THEN
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
          CALL FLAG_ERROR("Constraint equations is already associated.",ERR,ERROR,*999)
        ELSE
          CONSTRAINT_EQUATIONS=>CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS
          IF(.NOT.ASSOCIATED(CONSTRAINT_EQUATIONS)) &
            & CALL FLAG_ERROR("Constraint equations set equations is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint equations set has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations set is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_CONDITION_EQUATIONS_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_CONDITION_EQUATIONS_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_CONDITION_EQUATIONS_GET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_CONDITION_EQUATIONS_GET

  !
  !================================================================================================================================
  !
  
END MODULE CONSTRAINT_EQUATIONS_ROUTINES
